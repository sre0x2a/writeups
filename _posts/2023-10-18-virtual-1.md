---
title: virtual.1
date: 2023-10-18
---

Below details the analysis and subsequent key generator to "crack" the bytecode VM binary, virtual.1, found on the [crackmes.one](https://crackmes.one) website. The post is part of the "Blundering to Greatness" series that chronicles the journey of a software engineer and their attempts to become a software reverse engineer. The focus of the blog is on static binary analysis of CTFs, crackmes, and various other binary samples. Where appropriate other techniques will be used.

# Analysis of virtual.1

As mentioned above, the binary was found on the [crackmes.one](https://crackmes.one) website. It is a Linux ELF and is under the x86_64 assembly category for architecture and programming language. The website lists the binary as a level 3 out of a possible 6 in difficulty.

Running the strings command yields a few strings of interest. There is nothing that appears to be a key but just prompts and success/failure messages.

Ghidra will be used for the static analysis.

The binary is not stripped. Finding main is simple as the symbol is still in the binary. Jumping into the main function, one finds a menu being printed from a function titled `printmenu`. The user is then prompted to enter a username. The `fgets` function is used to populate a char array on the stack that takes up 250 bytes. The newline character is then replaced with the NULL byte. The user is then prompted for a serial that is also a 250 byte char array on the stack. `fgets` is again used to populate the serial char array. The same action of replacing the newline character with the NULL byte is performed.

The action occurs in the `vmstart` function. If the function returns a 1, the "Yep, you got it!" string is printed to the user. If the function does not return a 1, the "Nope, this is incorrect!" message is printed to the user. The `vmstart` function is passed the username and serial, in that order, before being called.

Inside the `vmstart` function, a 160 byte block in the `.data` section is zero filled. The username address is moved to an offset of 32 bytes into the block of memory. The serial is moved to offset of 40 bytes into the memory block. The next byte after the 160th byte in the block has its address moved to an offset of 56 bytes into the block of memory. The address of the block of memory is then passed to a function at 0x101830.

![vmstart](https://sre0x2a.github.io/writeups/assets/images/vmstart.png "vmstart")

The function loads an address into the `RSI` register. The base address has a quad word (8 byte) value taken from the memory block discussed above at offset 18. This address in the memory block will actually serve as the instruction pointer for the bytecode VM. The `LODSB` instruction is then used to load the byte at the base address plus the instruction pointer value into the `AL` register. The value in the `AL` register will be compared to a series of byte values that are the opcodes of the instruction set for the bytecode VM.

![Instruction Load](https://sre0x2a.github.io/writeups/assets/images/instruction_load.png "Instruction Load")

The following table details the bytecode instruction set.

|Opcode|Operation|Bytes|
|---|---|---:|
|0x01|MOVQ  rX,rY|3|
|0x02|MOVB  rX,rY|3|
|0x09|PUSHB  imm8|2|
|0x11|JMP  imm16|3|
|0x14|DECQ  rX|2|
|0x1e|TESTB  rX,rX|2|
|0x41|INCQ  rX|2|
|0x4c|EXIT|1|
|0x52|MOVZX  r0,byte ptr [serial]|1|
|0x54|TESTQ  rX,rX|2|
|0x55|JZ  imm16|3|
|0x56|MOVZX  rX,imm8|3|
|0x69|MOVZX  r0,byte ptr [username]|1|
|0x7f|CMPQ  rX,imm8|3|
|0x81|JNZ  imm16|3|
|0x8d|PUSHQ  rX|2|
|0x8e|POPQ  rX|2|
|0x8f|SHR  rX,imm8|3|
|0x90|TESTQ  rX,imm8|3|
|0x93|ADDQ  rX,rY|3|
|0x94|ANDQ  rX,imm64|10|
|0x95|JL  imm16|3|
|0x96|SUBB  rX,imm8|3|
|0x97|SHL  rX,imm8|3|
|0x98|CMPQ  rX,rY|3|
|0x99|MOVQ  rX,imm64|10|
|0x9a|ROLQ  rX,rY|3|
|0x9b|NOTB  rX|2|
|0x9c|XORB  rX,rY|3|
|0xab|CALL  imm16|3|
|0xba|RET|1|

A few notes of the instructions listed above. The `X` and `Y` are the first and second operand or bytes of the bytecode instruction for register operations. The bytecode VM instruction set seems to be a register based instruction set with the 160 byte memory block containing registers starting at offset 0 to 32 bytes. If one remembers, the 8 bytes at the 32 byte offset is the username and the 8 bytes at the 40 byte offset is the serial. The 8 bytes at the 56 byte offset ends up being the stack pointer. This is known from the reversing the PUSH and POP instructions and their reference to that address. 48 bytes into the memory block contains the flags that set from the CMP and TEST instructions. Finally the return value to main is placed at the 16 byte offset.

For convenience I simply thought of the 8 byte locations starting at offset 0 to offset 32 (exclusive) as r0, r1, r2, and r3. The `X` and `Y` mentioned above would evaluate to one of those value, [0, 3].

The imm8, imm16, and imm64 values are simply the operand(s) value taken as is and not as an offset to reference into the 160 byte block. Instructions 0x52 and 0x69 access the serial and username storage locations. I have those instructions as one would see as a dereferenced byte in assembly with serial and/or username as the memory address.

Investigating the bytecode loaded from the `.data` section at address 0x104100, shows a 192 block of bytes. I wrote a quick script to generate the hexdump of the bytecode seen below.

![Bytecode](https://sre0x2a.github.io/writeups/assets/images/hexdump.png "Bytecode")

The "disassembled" view of the bytes following the instruction set listed above can be found [here](https://sre0x2a.github.io/writeups/assets/files/insn.txt).

Investigating the disassembly identifies 5 functions. The first is found at 0x110 bytes into the bytecode and is an implementation of `strlen`. The `r0` register is used to pass the string as a parameter and the `r1` register is used to return the length of that string.

The second function, at 0xbe, converts two ASCII ranged bytes from the provided serial into the byte value they represent. Note, in this case the first byte will be the high order nibble of the byte and the second byte will be the low order nibble of the byte. The actual loading of the serial byte and the conversion are performed in another function located at 0x9a. The function intially checks if the byte is in the range [48, 57] or [65, 70]. After passing the check either a 48 is subtracted from the byte if it is in the range [48, 57] or 55 for the range [65, 70]. The converted value is then returned to the 0xbe function in the r0 register. Note the function increments the pointer to the "current" byte of the serial with each call.

Back in the function at 0xbe, 0x9a is called with its returned value copied to the `r2` register and then shifted 4 bits to the left. 0x9a is called again with the return value added to the `r2` register result. The function then returns.

The third function, located at 0xef, pushes the address for the username on the stack before loading the byte being pointed to and advancing the pointer to the username address. The byte value is tested to see if its value is 0. If it is not the function returns with the byte in the `r0` register.

The function located at 0x4b converts a string's 16 ASCII bytes to their respective value as an 8 byte value via the 0xbe function in a loop of 8 iterations.

The fifth function, located at 0xce, finds the number of on or 1 bits in a byte.
