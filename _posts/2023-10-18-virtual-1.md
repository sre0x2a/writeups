---
title: virtual.1
date: 2023-10-18
---

# Analysis of virtual.1

Below details the analysis and subsequent key generator to "crack" the bytecode VM binary, virtual.1, found on the [crackmes.one](https://crackmes.one) website. The post is part of the "Blundering to Greatness" series that chronicles the journey of a software engineer and their attempts to become a software reverse engineer. The focus of the blog is on static binary analysis of CTFs, crackmes, and various other binary samples. Where appropriate other techniques will be used.

### Bytecode VM

As mentioned above, the binary was found on the [crackmes.one](https://crackmes.one) website. It is a Linux ELF and is under the x86_64 assembly category for architecture and programming language. The website lists the binary as a level 3 out of a possible 6 in difficulty.

Running the strings command yields a few strings of interest. There is nothing that appears to be a key but just prompts and success/failure messages.

Ghidra will be used for the static analysis.

The binary is not stripped. Finding main is simple as the symbol is still in the binary. Jumping into the main function, one finds a menu being printed from a function titled `printmenu`. The user is then prompted to enter a username. The `fgets` function is used to populate a char array on the stack that takes up 250 bytes. The newline character is then replaced with the NULL byte. The user is then prompted for a serial that is also a 250 byte char array on the stack. `fgets` is again used to populate the serial char array. The same action of replacing the newline character with the NULL byte is performed.

The action occurs in the `vmstart` function. If the function returns a 1, the "Yep, you got it!" string is printed to the user. If the function does not return a 1, the "Nope, this is incorrect!" message is printed to the user. The `vmstart` function is passed the username and serial, in that order, before being called.

Inside the `vmstart` function, a 160 byte block in the `.data` section is zero filled. The username address is moved to an offset of 32 bytes into the block of memory. The serial is moved to offset of 40 bytes into the memory block. The next byte after the 160th byte in the block has its address moved to an offset of 56 bytes into the block of memory. The address of the block of memory is then passed to a function at 0x101830.

![vmstart](https://sre0x2a.github.io/writeups/assets/images/vmstart.png "vmstart")

The function loads an address into the `RSI` register. The base address has a quad word (8 byte) value taken from the memory block discussed above at offset 18. This address in the memory block will actually serve as the instruction pointer for the bytecode VM. The `LODSB` instruction is then used to load the byte at the base address plus the instruction pointer value into the `AL` register. The value in the `AL` will be compared to a series of byte values that are the opcodes of the instruction set for the bytecode VM.

![Instruction Load](https://sre0x2a.github.io/writeups/assets/images/instruction_load.png "Instruction Load")

The following table details the bytecode instruction set.

|Opcode|Operation|Bytes|
|---|---|---:|
|0x01|MOVQ  rX,rY|3|
|0x02|MOVB  rX,rY|3|
|0x09|PUSHB  imm8|2|
|0x11|JMP  imm16|3|
|0x14|DECQ  rX|2|
|0x1e|TESTB  rX,rX|2|
|0x41|INCQ  rX|2|
|0x4c|EXIT|1|
|0x52|MOVZX  r0,byte ptr [serial]|1|
|0x54|TESTQ  rX,rX|2|
|0x55|JZ  imm16|3|
|0x56|MOVZX  rX,imm8|3|
|0x69|MOVZX  r0,byte ptr [username]|1|
|0x7f|CMPQ  rX,imm8|3|
|0x81|JNZ  imm16|3|
|0x8d|PUSHQ  rX|2|
|0x8e|POPQ  rX|2|
|0x8f|SHR  rX,imm8|3|
|0x90|TESTQ  rX,imm8|3|
|0x93|ADDQ  rX,rY|3|
|0x94|ANDQ  rX,imm64|10|
|0x95|JL  imm16|3|
|0x96|SUBB  rX,imm8|3|
|0x97|SHL  rX,imm8|3|
|0x98|CMPQ  rX,rY|3|
|0x99|MOVQ  rX,imm64|10|
|0x9a|ROLQ  rX,rY|3|
|0x9b|NOTB  rX|2|
|0x9c|XORB  rX,rY|3|
|0xab|CALL  imm16|3|
|0xba|RET|1|

A few notes of the instruction listed above. The `X` and `Y` are the first and second operand or bytes of the bytecode instruction for register operations. The bytecode VM instruction set seems to be a register based instruction set with 160 memory block containing registers starting at offset 0 to 32 bytes. If one remembers the 8 bytes at the 32 bytes is the username and the 8 bytes at 40 bytes is the serial. The 8 bytes at 56 bytes ends up being the stack pointer. This is known from the reversing the PUSH and POP instruction and their reference to that address. 48 bytes into the memory block contains the flags set from the CMP and TEST instructions. Finally the return value to main is placed at 16 bytes.

For convenience I simply thought of the 8 byte offset from 0 to 32 bytes as r0, r1, r2, and r3. The `X` and `Y` mentioned above would evaluate to one of those value, [0, 3].

The imm8, imm16, and imm64 values are simply the operand(s) value taken as is and not as an offset to reference into the 160 byte block. Instructions 0x52 and 0x69 access the serial and username storage locations. I have those instructions as one would see dereference byte in assembly with serial and/or username as memory address.

Investigating the bytecode loaded from the `.data` section at address 0x104100, shows a 192 block of bytes. I wrote a quick script to generate the hexdump of the bytecode seen below.

![Bytecode](https://sre0x2a.github.io/writeups/assets/images/hexdump.png "Bytecode")
